/* This file is automatically generated */
#include "GraphBLAS.h"
char *GxB_IMPLEMENTATION_ABOUT_STR = GxB_IMPLEMENTATION_ABOUT;
char *GxB_IMPLEMENTATION_DATE_STR = GxB_IMPLEMENTATION_DATE;
char *GxB_IMPLEMENTATION_LICENSE_STR = GxB_IMPLEMENTATION_LICENSE;
char *GxB_IMPLEMENTATION_NAME_STR = GxB_IMPLEMENTATION_NAME;
char *GxB_SPEC_ABOUT_STR = GxB_SPEC_ABOUT;
char *GxB_SPEC_DATE_STR = GxB_SPEC_DATE;

extern GrB_Index GB_Iterator_rc_geti_(GxB_Iterator iterator)
{
  return (iterator->Ai != 0) ? (iterator->Ai[iterator->p]) : (iterator->p - iterator->pstart);
}

extern GrB_Index GB_Iterator_rc_getj_(GxB_Iterator iterator)
{
  if (iterator->k >= iterator->anvec)
  {
    return iterator->avdim;
  }
  else
    if (iterator->A_sparsity == 1)
  {
    return iterator->Ah[iterator->k];
  }
  else
  {
    return iterator->k;
  }
}

extern GrB_Index GxB_Matrix_Iterator_getp_(GxB_Iterator iterator)
{
  return iterator->p;
}

extern GrB_Index GxB_Matrix_Iterator_getpmax_(GxB_Iterator iterator)
{
  return iterator->pmax;
}

extern GrB_Index GxB_Vector_Iterator_getIndex_(GxB_Iterator iterator)
{
  return (iterator->Ai != 0) ? (iterator->Ai[iterator->p]) : (iterator->p);
}

extern GrB_Index GxB_Vector_Iterator_getp_(GxB_Iterator iterator)
{
  return iterator->p;
}

extern GrB_Index GxB_Vector_Iterator_getpmax_(GxB_Iterator iterator)
{
  return iterator->pmax;
}

extern GrB_Index GxB_colIterator_getColIndex_(GxB_Iterator iterator)
{
  return GB_Iterator_rc_getj(iterator);
}

extern GrB_Index GxB_colIterator_getRowIndex_(GxB_Iterator iterator)
{
  return GB_Iterator_rc_geti(iterator);
}

extern GrB_Index GxB_colIterator_kount_(GxB_Iterator iterator)
{
  return iterator->anvec;
}

extern GrB_Index GxB_rowIterator_getColIndex_(GxB_Iterator iterator)
{
  return GB_Iterator_rc_geti(iterator);
}

extern GrB_Index GxB_rowIterator_getRowIndex_(GxB_Iterator iterator)
{
  return GB_Iterator_rc_getj(iterator);
}

extern GrB_Index GxB_rowIterator_kount_(GxB_Iterator iterator)
{
  return iterator->anvec;
}

extern GrB_Info GB_Iterator_rc_bitmap_next_(GxB_Iterator iterator)
{
  for (; iterator->p < iterator->pend; iterator->p++)
  {
    if (iterator->Ab[iterator->p])
    {
      return GrB_SUCCESS;
    }
  }

  return GrB_NO_VALUE;
}

extern GrB_Info GB_Iterator_rc_inext_(GxB_Iterator iterator)
{
  if ((++iterator->p) >= iterator->pend)
  {
    return GrB_NO_VALUE;
  }
  else
    if (iterator->A_sparsity == 4)
  {
    return GB_Iterator_rc_bitmap_next(iterator);
  }
  else
  {
    return GrB_SUCCESS;
  }
}

extern GrB_Info GB_Iterator_rc_knext_(GxB_Iterator iterator)
{
  if ((++iterator->k) >= iterator->anvec)
  {
    iterator->pstart = 0;
    iterator->pend = 0;
    iterator->p = 0;
    iterator->k = iterator->anvec;
    return GxB_EXHAUSTED;
  }
  switch (iterator->A_sparsity)
  {
    default:

    case 2:

    case 1:
    {
      iterator->pstart = iterator->Ap[iterator->k];
      iterator->pend = iterator->Ap[iterator->k + 1];
      iterator->p = iterator->pstart;
    }
      break;

    case 4:
    {
      iterator->pstart += iterator->avlen;
      iterator->pend += iterator->avlen;
      iterator->p = iterator->pstart;
      return GB_Iterator_rc_bitmap_next(iterator);
    }
      break;

    case 8:
    {
      iterator->pstart += iterator->avlen;
      iterator->pend += iterator->avlen;
      iterator->p = iterator->pstart;
    }
      break;

  }

  return (iterator->p >= iterator->pend) ? (GrB_NO_VALUE) : (GrB_SUCCESS);
}

extern GrB_Info GxB_Matrix_Iterator_attach_(GxB_Iterator iterator, GrB_Matrix A, GrB_Descriptor desc)
{
  return GB_Iterator_attach(iterator, A, GxB_NO_FORMAT, desc);
}

extern GrB_Info GxB_Vector_Iterator_next_(GxB_Iterator iterator)
{
  if ((++iterator->p) >= iterator->pmax)
  {
    iterator->p = iterator->pmax;
    return GxB_EXHAUSTED;
  }
  return GrB_SUCCESS;
}

extern GrB_Info GxB_Vector_Iterator_seek_(GxB_Iterator iterator, GrB_Index p)
{
  if (p >= iterator->pmax)
  {
    iterator->p = iterator->pmax;
    return GxB_EXHAUSTED;
  }
  else
  {
    iterator->p = p;
    if (iterator->A_sparsity == 4)
    {
      for (; iterator->p < iterator->pmax; iterator->p++)
      {
        if (iterator->Ab[iterator->p])
        {
          return GrB_SUCCESS;
        }
      }

      return GxB_EXHAUSTED;
    }
  }
  return GrB_SUCCESS;
}

extern GrB_Info GxB_colIterator_attach_(GxB_Iterator iterator, GrB_Matrix A, GrB_Descriptor desc)
{
  return GB_Iterator_attach(iterator, A, GxB_BY_COL, desc);
}

extern GrB_Info GxB_colIterator_kseek_(GxB_Iterator iterator, GrB_Index k)
{
  return GB_Iterator_rc_seek(iterator, k, 1);
}

extern GrB_Info GxB_colIterator_nextCol_(GxB_Iterator iterator)
{
  return GB_Iterator_rc_knext(iterator);
}

extern GrB_Info GxB_colIterator_nextRow_(GxB_Iterator iterator)
{
  return GB_Iterator_rc_inext(iterator);
}

extern GrB_Info GxB_colIterator_seekCol_(GxB_Iterator iterator, GrB_Index col)
{
  return GB_Iterator_rc_seek(iterator, col, 0);
}

extern GrB_Info GxB_rowIterator_attach_(GxB_Iterator iterator, GrB_Matrix A, GrB_Descriptor desc)
{
  return GB_Iterator_attach(iterator, A, GxB_BY_ROW, desc);
}

extern GrB_Info GxB_rowIterator_kseek_(GxB_Iterator iterator, GrB_Index k)
{
  return GB_Iterator_rc_seek(iterator, k, 1);
}

extern GrB_Info GxB_rowIterator_nextCol_(GxB_Iterator iterator)
{
  return GB_Iterator_rc_inext(iterator);
}

extern GrB_Info GxB_rowIterator_nextRow_(GxB_Iterator iterator)
{
  return GB_Iterator_rc_knext(iterator);
}

extern GrB_Info GxB_rowIterator_seekRow_(GxB_Iterator iterator, GrB_Index row)
{
  return GB_Iterator_rc_seek(iterator, row, 0);
}

extern GxB_FC32_t GxB_Iterator_get_FC32_(GxB_Iterator iterator)
{
  return ((GxB_FC32_t *) iterator->Ax)[(iterator->iso) ? (0) : (iterator->p)];
}

extern GxB_FC64_t GxB_Iterator_get_FC64_(GxB_Iterator iterator)
{
  return ((GxB_FC64_t *) iterator->Ax)[(iterator->iso) ? (0) : (iterator->p)];
}

extern bool GxB_Iterator_get_BOOL_(GxB_Iterator iterator)
{
  return ((bool *) iterator->Ax)[(iterator->iso) ? (0) : (iterator->p)];
}

extern double GxB_Iterator_get_FP64_(GxB_Iterator iterator)
{
  return ((double *) iterator->Ax)[(iterator->iso) ? (0) : (iterator->p)];
}

extern float GxB_Iterator_get_FP32_(GxB_Iterator iterator)
{
  return ((float *) iterator->Ax)[(iterator->iso) ? (0) : (iterator->p)];
}

extern int8_t GxB_Iterator_get_INT8_(GxB_Iterator iterator)
{
  return ((int8_t *) iterator->Ax)[(iterator->iso) ? (0) : (iterator->p)];
}

extern int16_t GxB_Iterator_get_INT16_(GxB_Iterator iterator)
{
  return ((int16_t *) iterator->Ax)[(iterator->iso) ? (0) : (iterator->p)];
}

extern int32_t GxB_Iterator_get_INT32_(GxB_Iterator iterator)
{
  return ((int32_t *) iterator->Ax)[(iterator->iso) ? (0) : (iterator->p)];
}

extern int64_t GxB_Iterator_get_INT64_(GxB_Iterator iterator)
{
  return ((uint64_t *) iterator->Ax)[(iterator->iso) ? (0) : (iterator->p)];
}

extern uint8_t GxB_Iterator_get_UINT8_(GxB_Iterator iterator)
{
  return ((uint8_t *) iterator->Ax)[(iterator->iso) ? (0) : (iterator->p)];
}

extern uint16_t GxB_Iterator_get_UINT16_(GxB_Iterator iterator)
{
  return ((uint16_t *) iterator->Ax)[(iterator->iso) ? (0) : (iterator->p)];
}

extern uint32_t GxB_Iterator_get_UINT32_(GxB_Iterator iterator)
{
  return ((uint32_t *) iterator->Ax)[(iterator->iso) ? (0) : (iterator->p)];
}

extern uint64_t GxB_Iterator_get_UINT64_(GxB_Iterator iterator)
{
  return ((uint64_t *) iterator->Ax)[(iterator->iso) ? (0) : (iterator->p)];
}

extern void GxB_Iterator_get_UDT_(GxB_Iterator iterator, void *value)
{
  memcpy(value, iterator->Ax + ((iterator->iso) ? (0) : (iterator->type_size * iterator->p)), iterator->type_size);
}

extern void GxB_Matrix_Iterator_getIndex_(GxB_Iterator iterator, GrB_Index *row, GrB_Index *col)
{
  switch (iterator->A_sparsity)
  {
    default:

    case 2:
    {
      if (iterator->by_col)
      {
        *row = iterator->Ai[iterator->p];
        *col = iterator->k;
      }
      else
      {
        *row = iterator->k;
        *col = iterator->Ai[iterator->p];
      }
    }
      break;

    case 1:
    {
      if (iterator->by_col)
      {
        *row = iterator->Ai[iterator->p];
        *col = iterator->Ah[iterator->k];
      }
      else
      {
        *row = iterator->Ah[iterator->k];
        *col = iterator->Ai[iterator->p];
      }
    }
      break;

    case 4:

    case 8:
    {
      if (iterator->by_col)
      {
        *row = iterator->p - iterator->pstart;
        *col = iterator->k;
      }
      else
      {
        *row = iterator->k;
        *col = iterator->p - iterator->pstart;
      }
    }
      break;

  }

}
