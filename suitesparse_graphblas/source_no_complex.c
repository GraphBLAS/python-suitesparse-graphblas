/* This file is automatically generated */
#include "GraphBLAS.h"
char *GxB_IMPLEMENTATION_ABOUT_STR = GxB_IMPLEMENTATION_ABOUT;
char *GxB_IMPLEMENTATION_DATE_STR = GxB_IMPLEMENTATION_DATE;
char *GxB_IMPLEMENTATION_LICENSE_STR = GxB_IMPLEMENTATION_LICENSE;
char *GxB_IMPLEMENTATION_NAME_STR = GxB_IMPLEMENTATION_NAME;
char *GxB_SPEC_ABOUT_STR = GxB_SPEC_ABOUT;
char *GxB_SPEC_DATE_STR = GxB_SPEC_DATE;

inline static GrB_Info GB_Iterator_rc_bitmap_next(GxB_Iterator iterator)
{
  for (; iterator->p < iterator->pend; iterator->p++)
  {
    if (iterator->Ab[iterator->p])
    {
      return GrB_SUCCESS;
    }
  }

  return GrB_NO_VALUE;
}

inline static GrB_Info GB_Iterator_rc_knext(GxB_Iterator iterator)
{
  if ((++iterator->k) >= iterator->anvec)
  {
    iterator->pstart = 0;
    iterator->pend = 0;
    iterator->p = 0;
    iterator->k = iterator->anvec;
    return GxB_EXHAUSTED;
  }
  switch (iterator->A_sparsity)
  {
    default:

    case 2:

    case 1:
    {
      iterator->pstart = iterator->Ap[iterator->k];
      iterator->pend = iterator->Ap[iterator->k + 1];
      iterator->p = iterator->pstart;
    }
      break;

    case 4:
    {
      iterator->pstart += iterator->avlen;
      iterator->pend += iterator->avlen;
      iterator->p = iterator->pstart;
      return GB_Iterator_rc_bitmap_next(iterator);
    }
      break;

    case 8:
    {
      iterator->pstart += iterator->avlen;
      iterator->pend += iterator->avlen;
      iterator->p = iterator->pstart;
    }
      break;

  }

  return (iterator->p >= iterator->pend) ? (GrB_NO_VALUE) : (GrB_SUCCESS);
}

inline static GrB_Info GB_Iterator_rc_inext(GxB_Iterator iterator)
{
  if ((++iterator->p) >= iterator->pend)
  {
    return GrB_NO_VALUE;
  }
  else
    if (iterator->A_sparsity == 4)
  {
    return GB_Iterator_rc_bitmap_next(iterator);
  }
  else
  {
    return GrB_SUCCESS;
  }
}

inline static GrB_Index GB_Iterator_rc_getj(GxB_Iterator iterator)
{
  if (iterator->k >= iterator->anvec)
  {
    return iterator->avdim;
  }
  else
    if (iterator->A_sparsity == 1)
  {
    return iterator->Ah[iterator->k];
  }
  else
  {
    return iterator->k;
  }
}

inline static GrB_Index GB_Iterator_rc_geti(GxB_Iterator iterator)
{
  return (iterator->Ai != 0) ? (iterator->Ai[iterator->p]) : (iterator->p - iterator->pstart);
}

inline static GrB_Info GxB_rowIterator_attach(GxB_Iterator iterator, GrB_Matrix A, GrB_Descriptor desc)
{
  return GB_Iterator_attach(iterator, A, GxB_BY_ROW, desc);
}

inline static GrB_Index GxB_rowIterator_kount(GxB_Iterator iterator)
{
  return iterator->anvec;
}

inline static GrB_Info GxB_rowIterator_seekRow(GxB_Iterator iterator, GrB_Index row)
{
  return GB_Iterator_rc_seek(iterator, row, 0);
}

inline static GrB_Info GxB_rowIterator_kseek(GxB_Iterator iterator, GrB_Index k)
{
  return GB_Iterator_rc_seek(iterator, k, 1);
}

inline static GrB_Info GxB_rowIterator_nextRow(GxB_Iterator iterator)
{
  return GB_Iterator_rc_knext(iterator);
}

inline static GrB_Info GxB_rowIterator_nextCol(GxB_Iterator iterator)
{
  return GB_Iterator_rc_inext(iterator);
}

inline static GrB_Index GxB_rowIterator_getRowIndex(GxB_Iterator iterator)
{
  return GB_Iterator_rc_getj(iterator);
}

inline static GrB_Index GxB_rowIterator_getColIndex(GxB_Iterator iterator)
{
  return GB_Iterator_rc_geti(iterator);
}

inline static GrB_Info GxB_colIterator_attach(GxB_Iterator iterator, GrB_Matrix A, GrB_Descriptor desc)
{
  return GB_Iterator_attach(iterator, A, GxB_BY_COL, desc);
}

inline static GrB_Index GxB_colIterator_kount(GxB_Iterator iterator)
{
  return iterator->anvec;
}

inline static GrB_Info GxB_colIterator_seekCol(GxB_Iterator iterator, GrB_Index col)
{
  return GB_Iterator_rc_seek(iterator, col, 0);
}

inline static GrB_Info GxB_colIterator_kseek(GxB_Iterator iterator, GrB_Index k)
{
  return GB_Iterator_rc_seek(iterator, k, 1);
}

inline static GrB_Info GxB_colIterator_nextCol(GxB_Iterator iterator)
{
  return GB_Iterator_rc_knext(iterator);
}

inline static GrB_Info GxB_colIterator_nextRow(GxB_Iterator iterator)
{
  return GB_Iterator_rc_inext(iterator);
}

inline static GrB_Index GxB_colIterator_getColIndex(GxB_Iterator iterator)
{
  return GB_Iterator_rc_getj(iterator);
}

inline static GrB_Index GxB_colIterator_getRowIndex(GxB_Iterator iterator)
{
  return GB_Iterator_rc_geti(iterator);
}

inline static GrB_Info GxB_Matrix_Iterator_attach(GxB_Iterator iterator, GrB_Matrix A, GrB_Descriptor desc)
{
  return GB_Iterator_attach(iterator, A, GxB_NO_FORMAT, desc);
}

inline static GrB_Index GxB_Matrix_Iterator_getpmax(GxB_Iterator iterator)
{
  return iterator->pmax;
}

inline static GrB_Index GxB_Matrix_Iterator_getp(GxB_Iterator iterator)
{
  return iterator->p;
}

inline static void GxB_Matrix_Iterator_getIndex(GxB_Iterator iterator, GrB_Index *row, GrB_Index *col)
{
  switch (iterator->A_sparsity)
  {
    default:

    case 2:
    {
      if (iterator->by_col)
      {
        *row = iterator->Ai[iterator->p];
        *col = iterator->k;
      }
      else
      {
        *row = iterator->k;
        *col = iterator->Ai[iterator->p];
      }
    }
      break;

    case 1:
    {
      if (iterator->by_col)
      {
        *row = iterator->Ai[iterator->p];
        *col = iterator->Ah[iterator->k];
      }
      else
      {
        *row = iterator->Ah[iterator->k];
        *col = iterator->Ai[iterator->p];
      }
    }
      break;

    case 4:

    case 8:
    {
      if (iterator->by_col)
      {
        *row = iterator->p - iterator->pstart;
        *col = iterator->k;
      }
      else
      {
        *row = iterator->k;
        *col = iterator->p - iterator->pstart;
      }
    }
      break;

  }

}

inline static GrB_Index GxB_Vector_Iterator_getpmax(GxB_Iterator iterator)
{
  return iterator->pmax;
}

inline static GrB_Info GxB_Vector_Iterator_seek(GxB_Iterator iterator, GrB_Index p)
{
  if (p >= iterator->pmax)
  {
    iterator->p = iterator->pmax;
    return GxB_EXHAUSTED;
  }
  else
  {
    iterator->p = p;
    if (iterator->A_sparsity == 4)
    {
      for (; iterator->p < iterator->pmax; iterator->p++)
      {
        if (iterator->Ab[iterator->p])
        {
          return GrB_SUCCESS;
        }
      }

      return GxB_EXHAUSTED;
    }
  }
  return GrB_SUCCESS;
}

inline static GrB_Info GxB_Vector_Iterator_next(GxB_Iterator iterator)
{
  if ((++iterator->p) >= iterator->pmax)
  {
    iterator->p = iterator->pmax;
    return GxB_EXHAUSTED;
  }
  return GrB_SUCCESS;
}

inline static GrB_Index GxB_Vector_Iterator_getp(GxB_Iterator iterator)
{
  return iterator->p;
}

inline static GrB_Index GxB_Vector_Iterator_getIndex(GxB_Iterator iterator)
{
  return (iterator->Ai != 0) ? (iterator->Ai[iterator->p]) : (iterator->p);
}

inline static bool GxB_Iterator_get_BOOL(GxB_Iterator iterator)
{
  return ((bool *) iterator->Ax)[(iterator->iso) ? (0) : (iterator->p)];
}

inline static int8_t GxB_Iterator_get_INT8(GxB_Iterator iterator)
{
  return ((int8_t *) iterator->Ax)[(iterator->iso) ? (0) : (iterator->p)];
}

inline static int16_t GxB_Iterator_get_INT16(GxB_Iterator iterator)
{
  return ((int16_t *) iterator->Ax)[(iterator->iso) ? (0) : (iterator->p)];
}

inline static int32_t GxB_Iterator_get_INT32(GxB_Iterator iterator)
{
  return ((int32_t *) iterator->Ax)[(iterator->iso) ? (0) : (iterator->p)];
}

inline static int64_t GxB_Iterator_get_INT64(GxB_Iterator iterator)
{
  return ((uint64_t *) iterator->Ax)[(iterator->iso) ? (0) : (iterator->p)];
}

inline static uint8_t GxB_Iterator_get_UINT8(GxB_Iterator iterator)
{
  return ((uint8_t *) iterator->Ax)[(iterator->iso) ? (0) : (iterator->p)];
}

inline static uint16_t GxB_Iterator_get_UINT16(GxB_Iterator iterator)
{
  return ((uint16_t *) iterator->Ax)[(iterator->iso) ? (0) : (iterator->p)];
}

inline static uint32_t GxB_Iterator_get_UINT32(GxB_Iterator iterator)
{
  return ((uint32_t *) iterator->Ax)[(iterator->iso) ? (0) : (iterator->p)];
}

inline static uint64_t GxB_Iterator_get_UINT64(GxB_Iterator iterator)
{
  return ((uint64_t *) iterator->Ax)[(iterator->iso) ? (0) : (iterator->p)];
}

inline static float GxB_Iterator_get_FP32(GxB_Iterator iterator)
{
  return ((float *) iterator->Ax)[(iterator->iso) ? (0) : (iterator->p)];
}

inline static double GxB_Iterator_get_FP64(GxB_Iterator iterator)
{
  return ((double *) iterator->Ax)[(iterator->iso) ? (0) : (iterator->p)];
}

inline static void GxB_Iterator_get_UDT(GxB_Iterator iterator, void *value)
{
  memcpy(value, iterator->Ax + ((iterator->iso) ? (0) : (iterator->type_size * iterator->p)), iterator->type_size);
}
